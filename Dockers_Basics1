Q>>Work with out docker: VMs for applications
---------- Needed host os --> hypervisor --> host os -->  binaries related to application

Q>With Docker?
-----------Docker engine on host os ---> assig binaries and libraries --> run the container

Q>What is the use of docker??
----------- To run the app quicky and less resource bcz of absent of host os

Q>> What is the docker?
----------  Docker is containerisation platfomr --> form Related packages and binaries and run them whihc are called as container---> can run in any platform



Q>Resource management in VM?
---------- in any vm per suppose if we provided 6 gb then vm use 4GB and left 2 gb free then 2 gb is waste
---------- in docker we can use that empty space for another container
---------- in VM for Guest os increase wait , perofrmance reduce, memorey high , stoage space high, network high absorb
-----------in docker no guest os so no need of multiple os so it is called ligh weight


Q>Integration with docker??
-----------Integration in docker is Faste, Cheap and easy scalable, using docker we can setup may instances like jenkins, puppet and more
-----------All can run in the same container or we can run them in different container which can interact with some commands
-----------we can also scallable these containers with the docker commands


Q>Difference between docker and docker engine?
-------------- In docker we have 3 components that are docker client, docker host and docker repository 
-------------- docker host + docker client = docker engine
--------------- docker clinet >> To run the docker realted commands like run, pull , build by the user, here user will interact with the docker client to perform all these activities
-------------- docker host >> docker host has 5 components 1> docker demon (whihc is docker service whihc is called dockerd) , 2> container 3> images 4> Network %> Storage
-------------- docker registry >> whihc is based in cloud , by default its docker registry to store the images for security we can create a private registry
-------------- work flow >> Docker commands -->docker demon >> docker host to create images 
-------------- after creating the images whihc we have to run by the command called docker container 
-------------- the saved images in the registery we can pull them and run in somany containers 



Docker Consepts::

Docker is a platform for developers and system admins to build, run and share applications with containers
the use of cintainers to deploy applications is called continerisation

Containerisation advantages:

1> Flexible: Any type of applications can be containerised
2>Lghtweight: Containers leverage and share the host ernal instead of insttaling the host os whihc makes more efficient in terms of system resources
3> Portable: we can run in your local, deploy to cloud and run any where 
4>LooselyCoupled: Containers are self sufficient and encapsulated, allowing you to replacce or upgrade one with out disturbing the others
5>Scalable: You can increase and automatically distribute container replicas across a datacenter
5>Secure: we an secure the docker container <pending>



Installing Docker>> Docker we can install in number of ways like yum, zip file ..etc


Running the containers::
------------ Runable instance of a image is called container, this container will connect with the networ

Cmmand to run the command: docker run [optios] image[:tag] [command] arg

Image: The container image to run,, by default it will pulled from the docker repository 


>>>>>A Docker image is a read-only template that contains a set of instructions for creating a container that can run on the Docker platform.
It provides a convenient way to package up applications and preconfigured server environments, 
which you can use for your own private use or share publicly with other Docker users.<<<<


TAG: A specific name for the tag usually we use tag

command: Command to run inside the container at the time of creating

Arg: Arguments to pass the when running the comand

Some available options:

-d : run the container in detached mode,, by using the run with out -d we can not run the in the backgroud means will move into the conatiner ater creating it so to keep the 
     container uo and running we have to exit from the container and have to start it again to avoide this we will use detached mode whihc makes the conatiner run in the background
 
 --name: we can provide specific name to our container, if we didn't providedthis name then container will assign a name to that container by deafault
 
 --restart: we can specify to the container that when it has to be restarted automatically, there are some optiosn for this restart 
            no : it is by default whihc means ti will never restart
            on-failure: only if the contaier fails like exit with a non zero code
            always: restart the container wether is succeeds or fails also starts the container automatically whe deamon startup we never used any wherea usualy
            
            unless-stopeed: restart the container wether is succeeds or fails also starts the container automatically whe deamon startup, unless the container was stopped manually
            
 
 -p: <host port>:<container port> : every time we have to give this while creating the container:  which expose container port by mapping it to the host port,, we can use multiple 
     ports by using the -p option multiple times
     
 -rm: automatically remove the container when exits, note:: --restarts can not use along with --rm
 
 --memory: used to set the memorey limit to the container
 
 --memory-reservation: a soft limit on memorey usage,, container will retricted to this limit if docker detects memorey contention
 
 
 
 
 Commands to work with the docker:
 
 docker ps ----->to list the containers running
 docker ps -a ----------->all container
 docker start/stop/rm <container-name>
 docker rm <image> ---------->to delete image
 docker save image > image.tar ------------ to convert the images into tar file
 docker load --input image.tar --------> to create the image from the tar file
 docker version -----> to check the version
 
 
 EXAMPLE:
 
 docker run -d --name nginx --restart unless-stopped -p 8080:80 --memorey 500M --memorey-reservatio 256M nginx
 Above comand to run the nginix container with the name nginx with the given ports/memorey/restart options
 
 
 
 Docker Logging drivers:
 
 Usually logging drivers are splunk ,json..etc
 these are called plugable frame work it is used to accss the data from the containers, 
 The Docker logging driver allows you send stdout and stderr output from your container to the host’s syslog daemon. 
 The syslog daemon on the host will then forward the logs to Loggly
 we can set options for these drivers for this we have to give some custominsed drivers from the existing drivers
 for this we have to chnge the some properties in /etc/docker/deamon.json
 to find out the drivers assigned currently by using the command docker info for specific out put
 we can check the running driver by default it is json-file
 under plugins we can find the some properties like Volume, Network and log.etc
 in log option we can check the available plugins
 to change this one change the configuration file in /etc/docker/deamon.json write the code in json to change the property
 here we can defined the sizr and driver type
 by deafault:
 
 {
   "log-driver": "json-file"
   "log-opts": {
     "max-size": "15m"
     }
 }
 
 restart the docker to get it reflet ,, check for the ther logging drives ???
 
 
 we can archive the above thing directly with run command at the time of creating the container with out editing the configuration file
 
 docker run --log-driver json-file --log-opt max-size=5om -p 80:80nginx
 
 above command will do the same for the specific container
 Note: if we forgot to provide the port in run command the container will exit 
 
 
 
 
 
 
 Docker File:
 -------------Docer file is used to create a docker image
 What is docker image:
 -------------Which contains software to run a container along with code and images
 How to create a docker image: 
 ------------ By using the file Dockerfile and the "D" should be in upper case and there shoudn't be any extention for this and it would be a single name, continer and images 
 are defined layered file systems,, each layer is different from the previous layer. Most of the layers are read only layer but the top layer willbe the writable layer
 
 Example: per suppose if we are using the ubuntu the take this ubuntu as base image and install python and run any web application on top of it. if we need the some other version
 with the same image then we can edit and add additional components the code in the writable layer so the top layer will almost be the writable layer,, This layered file system 
 allow the multiple containres and images same layers should be shared to narrow the storage foot print and transfer the image and build the image quickly.
 
 
 Dockerfile:
 ---------- If you want to build your own images we do with the dockerfile, docker file contian a set of intructions which are used to construct a docker images whihc are also
 called directives
 
 List of directives:
 
FROM: (always in upper case) 
-----------Starts a new build stage and sets the base image,, usually must be the first directive in the Dockerfile in some cases we can place args intially

ENV:
-----------To set the environiment variables, we can refer these inside the dockerfile and can availble in the container run time.

RUN:
-----------Creats the new layer on top of the previous layer by running a comand inside that new layer and commiting the changes
Example: on the base os which was installed by the FROM instruction if we need to install any software like a webservers, so we have to provide the webserver installation
command here in the RUN tag, this comand will commit in the new layer

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Do not confuse RUN with CMD. RUN actually runs a command and commits the result; CMD does not execute anything at build time, but specifies the intended command for the image.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


CMD:
----------Specify a default command used to run inside the container at the time of execution
Example: to start the webserver we use linux command whihc we have to provide here


More about the instruction:

FROM:
####
Usage:

FROM <image>
FROM <image>:<tag>

FROM must be the first non-comment instruction in the Dockerfile.
FROM can appear multiple times within a single Dockerfile in order to create multiple images. Simply make a note of the last image ID output by the commit before each 
new FROM command.


MAINTAINER:
##########

Usage:

MAINTAINER <name>
The MAINTAINER instruction allows you to set the Author field of the generated images.


RUN:
###

Usage:

RUN <command> (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows) 
RUN commands using a base image that does not contain the specified shell executable. >> RUN echo $VERSION > image_version


RUN ["<executable>", "<param1>", "<param2>"] (exec form)
The default shell for the shell form can be changed using the SHELL command. >> Exmple:RUN /bin/bash -c 'source $HOME/.bashrc; echo $HOME'


LABEL:
#####

Usage:

LABEL <key>=<value> [<key>=<value> ...]

The LABEL instruction adds metadata to an image.
To include spaces within a LABEL value, use quotes and backslashes as you would in command-line parsing.
Labels are additive including LABELs in FROM images.
If Docker encounters a label/key that already exists, the new value overrides any previous labels with identical keys.
To view an image’s labels, use the docker inspect command. They will be under the "Labels" JSON attribute.

>>docker image inspect --format='' myimage<<
Examples:
LABEL "com.example.vendor"="ACME Incorporated"
LABEL multi.label1="value1" multi.label2="value2" other="value3"
LABEL multi.label1="value1" \
      multi.label2="value2" \
      other="value3"

EXPOSE:
#######

Usage:

EXPOSE <port> [<port> ...]

Informs Docker that the container listens on the specified network port(s) at runtime.
EXPOSE does not make the ports of the container accessible to the host.

Example:
EXPOSE 80/tcp
EXPOSE 80/udp
we can archive the same in run time by using the -p option
docker run -p 80:80/tcp -p 80:80/udp ...
To set up port redirection on the host system, see using the -P flag

ADD:
###

The ADD instruction copies new files, directories or remote file URLs from <src> and adds them to the filesystem of the image at the path <dest>.

ADD <src> [<src> ...] <dest>
ADD ["<src>", ... "<dest>"] (this form is required for paths containing whitespace)

Wxamples
ADD hom* /mydir/
ADD hom?.txt /mydir/
In the above example below, ? is replaced with any single character, e.g., “home.txt”.

The <dest> is an absolute path, or a path relative to WORKDIR, into which the source will be copied inside the destination container.
The example below uses a relative path, and adds “test.txt” to <WORKDIR>/relativeDir/:
ADD test.txt relativeDir/


COPY:
#####

Usage:

COPY <src> [<src> ...] <dest>
COPY ["<src>", ... "<dest>"] (this form is required for paths containing whitespace)

Examples:
COPY hom* /mydir/
COPY hom?.txt /mydir/

The <dest> is an absolute path, or a path relative to WORKDIR, into which the source will be copied inside the destination container.
The example below uses a relative path, and adds “test.txt” to <WORKDIR>/relativeDir/:
COPY test.txt relativeDir/

Differeance between ADD and COPY:

COPY and ADD are both Dockerfile instructions that serve similar purposes. They let you copy files from a specific location into a Docker image.
COPY takes in a src and destination. It only lets you copy in a local file or directory from your host (the machine building the Docker image) into the Docker image itself.

ADD lets you do that too, but it also supports 2 other sources. First, you can use a URL instead of a local file / directory. Secondly, you can extract a tar file from the 
source directly into the destination.

Exampe: 
ADD http://example.com/big.tar.xz /usr/src/things/













 


 
 
 
 
 
 
 
 
     
     






